local Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/discoart/FluentPlus/refs/heads/main/Beta.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Zenscript " .. Fluent.Version,
    SubTitle = "zenith",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 420),
    Acrylic = true, -- Blur effect
    Theme = "Rose",
    MinimizeKey = Enum.KeyCode.LeftControl
})

-- Tabs
local Tabs = {
    Main = Window:AddTab({ Title = "Zenith Menus", Icon = "rbxassetid://10709769406" }),
    Settings = Window:AddTab({ Title = "README/LOGS", Icon = "FileSpreadsheet" }),
    QuickUtil = Window:AddTab({ Title = "Quick Util", Icon = "settings" })
}

-- MAIN TAB

 Toggle1 = Tabs.Main:AddToggle("MainToggle1", {
    Title = "Zen menu", 
    Description = "menu for common hacks",
    Default = false,
    Callback = function(state)
        if state then
            -- Run the hack and store its returned objects/functions for later cleanup
            local Hack = loadstring(game:HttpGet("https://raw.githubusercontent.com/WHOLEBAKERY/Zenscript/main/Zen"))()
            
            -- You may need the hack to provide a way to close its menu or stop effects
            -- For example, if Hack returns a table with a Destroy() or Close() function:
            Toggle1.HackInstance = Hack
            print("Zen menu Activated")
        else
            -- Cancel or clean up the hack
            if Toggle1.HackInstance and type(Toggle1.HackInstance.Destroy) == "function" then
                Toggle1.HackInstance:Destroy()  -- closes menu & cancels effects
            end
            print("Zen menu Deactivated")
        end
    end
})

local player = game:GetService("Players").LocalPlayer
local UserInputService = game:GetService("UserInputService")

local Toggle2 = Tabs.Main:AddToggle("MainToggle2", {
    Title = "Anti Freeze", 
    Description = "unfreeze the player where movement is restricted",
    Default = false,
    Callback = function(state)
        if state then
            -- Create GUI only when toggle is ON
            if not player:FindFirstChild("PlayerGui"):FindFirstChild("FreezeToggleUI") then
                local gui = Instance.new("ScreenGui")
                gui.Name = "FreezeToggleUI"
                gui.ResetOnSpawn = false
                gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
                gui.Parent = player:WaitForChild("PlayerGui")

                -- Create the button
                local btn = Instance.new("TextButton")
                btn.Size = UDim2.new(0, 150, 0, 40)
                btn.Position = UDim2.new(0.5, -75, 0.85, 0)
                btn.AnchorPoint = Vector2.new(0.5, 0)
                btn.Text = "Freeze"
                btn.TextColor3 = Color3.new(1, 1, 1)
                btn.Font = Enum.Font.GothamBold
                btn.TextSize = 18
                btn.Active = true
                btn.Draggable = true
                btn.Parent = gui

                -- Add outline
                local stroke = Instance.new("UIStroke", btn)
                stroke.Color = Color3.new(1, 1, 1)
                stroke.Thickness = 2

                -- Track state
                local frozenByButton = false

                local function freeze()
                    local char = player.Character or player.CharacterAdded:Wait()
                    local humanoid = char:FindFirstChildOfClass("Humanoid")
                    local root = char:FindFirstChild("HumanoidRootPart")

                    if humanoid then
                        humanoid.WalkSpeed = 0
                        humanoid.JumpPower = 0
                    end

                    if root then
                        root.Anchored = true
                    end

                    UserInputService.ModalEnabled = true
                    frozenByButton = true
                    btn.Text = "Unfreeze"
                    btn.BackgroundColor3 = Color3.fromRGB(255, 80, 80)
                end

                local function unfreeze()
                    local char = player.Character or player.CharacterAdded:Wait()
                    local humanoid = char:FindFirstChildOfClass("Humanoid")
                    local root = char:FindFirstChild("HumanoidRootPart")

                    if humanoid then
                        humanoid.WalkSpeed = 16
                        humanoid.JumpPower = 50
                    end

                    if root then
                        root.Anchored = false
                    end

                    -- Remove physical constraints just in case
                    for _, obj in ipairs(char:GetDescendants()) do
                        if obj:IsA("Constraint") or obj:IsA("Weld") then
                            pcall(function() obj:Destroy() end)
                        end
                    end

                    UserInputService.ModalEnabled = false
                    frozenByButton = false
                    btn.Text = "Freeze"
                    btn.BackgroundColor3 = Color3.fromRGB(80, 200, 80)
                end

                -- Toggle freeze/unfreeze
                btn.MouseButton1Click:Connect(function()
                    if frozenByButton then
                        unfreeze()
                    else
                        freeze()
                    end
                end)
            end

        else
            -- Destroy GUI when toggle is OFF
            local gui = player:FindFirstChild("PlayerGui"):FindFirstChild("FreezeToggleUI")
            if gui then
                gui:Destroy()
            end
        end
    end
})


-- Buttons on Main
Tabs.Main:AddButton({
    Title = "Attach tool",
    Description = "menu to attach to players",
    Callback = function()-- Attach Tool GUI with Dodge/Touch + C mini-mode
local Players = game:GetService("Players")
local UIS     = game:GetService("UserInputService")
local lp      = Players.LocalPlayer

-- Cleanup old GUI
local guiParent = lp:WaitForChild("PlayerGui")
local old = guiParent:FindFirstChild("AttachToolGui")
if old then old:Destroy() end

-- Create ScreenGui
local screen = Instance.new("ScreenGui", guiParent)
screen.Name = "AttachToolGui"

-- Main Frame
local frame = Instance.new("Frame", screen)
frame.Name = "MainFrame"
frame.Size = UDim2.new(0, 300, 0, 160)
frame.Position = UDim2.new(0.3, 0, 0.3, 0)
frame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
frame.Active = true
frame.Draggable = true

-- Helper to create TextButton
local function mkBtn(props, parent)
    local btn = Instance.new("TextButton", parent)
    for k,v in pairs(props) do btn[k] = v end
    return btn
end

-- Search Box
local searchBox = Instance.new("TextBox", frame)
searchBox.Size = UDim2.new(1, -20, 0, 25)
searchBox.Position = UDim2.new(0, 10, 0, 10)
searchBox.PlaceholderText = "Search display name..."
searchBox.ClearTextOnFocus = false
searchBox.Font = Enum.Font.SourceSans
searchBox.TextSize = 18
searchBox.Text = ""

-- Core UI Buttons
local selBtn = mkBtn({ Size = UDim2.new(1, -110, 0, 25), Position = UDim2.new(0, 10, 0, 45),
    BackgroundColor3 = Color3.fromRGB(70,70,70), TextColor3 = Color3.new(1,1,1),
    Font = Enum.Font.SourceSansBold, TextSize = 18, Text = "Selected: None" }, frame)

local copyBtn = mkBtn({ Size = UDim2.new(0, 80, 0, 25), Position = UDim2.new(1, -90, 0, 45),
    BackgroundColor3 = Color3.fromRGB(70,70,70), TextColor3 = Color3.new(1,1,1),
    Font = Enum.Font.SourceSansBold, TextSize = 18, Text = "Copy" }, frame)

local prevBtn = mkBtn({ Size = UDim2.new(0, 40, 0, 30), Position = UDim2.new(0.05, 0, 0.65, 0), Text = "<<" }, frame)
local nextBtn = mkBtn({ Size = UDim2.new(0, 40, 0, 30), Position = UDim2.new(0.2, 0, 0.65, 0), Text = ">>" }, frame)

local attachBtn = mkBtn({ Size = UDim2.new(0, 100, 0, 30), Position = UDim2.new(0.5, -50, 0.65, 0), Text = "Attach: OFF" }, frame)
local dirBtn    = mkBtn({ Size = UDim2.new(0, 100, 0, 25), Position = UDim2.new(0.05, 0, 0.45, 0), Text = "Direction: Behind" }, frame)

local distDec = mkBtn({ Size = UDim2.new(0, 20, 0, 20), Position = UDim2.new(0.65, 0, 0.85, 0), Text = "-" }, frame)
local distBox = Instance.new("TextLabel", frame)
distBox.Size = UDim2.new(0, 50, 0, 20); distBox.Position = UDim2.new(0.75, 0, 0.85, 0)
distBox.Text = "5"; distBox.BackgroundTransparency = 1; distBox.Font = Enum.Font.SourceSans; distBox.TextSize = 18; distBox.TextColor3 = Color3.new(1,1,1)
local distInc = mkBtn({ Size = UDim2.new(0, 20, 0, 20), Position = UDim2.new(0.85, 0, 0.85, 0), Text = "+" }, frame)

local minimizeBtn = mkBtn({ Size = UDim2.new(0, 20, 0, 20), Position = UDim2.new(1, -45, 0, 5),
    BackgroundColor3 = Color3.fromRGB(80,80,80), TextColor3 = Color3.new(1,1,1),
    Font = Enum.Font.SourceSansBold, TextSize = 14, Text = "_" }, frame)

local closeBtn = mkBtn({ Size = UDim2.new(0, 20, 0, 20), Position = UDim2.new(1, -25, 0, 5),
    BackgroundColor3 = Color3.fromRGB(120,40,40), TextColor3 = Color3.new(1,1,1),
    Font = Enum.Font.SourceSansBold, TextSize = 14, Text = "X" }, frame)

local miniBtn = mkBtn({ Size = UDim2.new(0, 30, 0, 30), Position = frame.Position,
    BackgroundColor3 = Color3.fromRGB(60,60,60), TextColor3 = Color3.new(1,1,1),
    Font = Enum.Font.SourceSansBold, TextSize = 20, Text = "A", Visible = false }, screen)

-- New Buttons: Dodge/Touch & C
local dodgeBtn = mkBtn({ Size = UDim2.new(0, 80, 0, 30), Position = UDim2.new(0.65, 0, 0.65, 0), Text = "DODGE" }, frame)
local cBtn     = mkBtn({ Size = UDim2.new(0, 20, 0, 20), Position = UDim2.new(1, -65, 0, 5),
    BackgroundColor3 = Color3.fromRGB(80,80,80), TextColor3 = Color3.new(1,1,1),
    Font = Enum.Font.SourceSansBold, TextSize = 14, Text = "C" }, frame)

-- State Variables
local dist = 5
local attached = false
local alignPos, alignOri, att0, att1
local playerList = {} ; local idx = 1 ; local modes = {"behind","front","left","right"} ; local modeIndex = 1
local returnCF, lastTarget
local smallMode = false
local hiddenState = {}

-- Refresh player list
local function refreshList()
    playerList = {}
    local term = searchBox.Text:lower()
    local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    for _,p in ipairs(Players:GetPlayers()) do
        if p~=lp and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
            if term == "" or p.DisplayName:lower():find(term) then
                local d = hrp and (p.Character.HumanoidRootPart.Position - hrp.Position).Magnitude or math.huge
                table.insert(playerList,{p=p,d=d})
            end
        end
    end
    table.sort(playerList,function(a,b) return a.d < b.d end)
    idx = 1
    selBtn.Text = #playerList>0 and "Selected: "..playerList[1].p.DisplayName or "Selected: None"
end

-- Detach attachments
local function detach()
    if alignPos then alignPos:Destroy() end
    if alignOri then alignOri:Destroy() end
    if att0 then att0:Destroy() end
    if att1 then att1:Destroy() end
    attached = false
    attachBtn.Text = "Attach: OFF"
end

-- Attach to target player
local function attachTo(p)
    local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    if hrp and not attached then
        returnCF = hrp.CFrame
        lastTarget = p
    end
    detach()
    hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    local thrp = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
    if not hrp or not thrp then return end
    local mode = modes[modeIndex]
    local offset = Vector3.new(
        (mode=="left"  and -dist) or (mode=="right" and dist) or 0,
        0,
        (mode=="behind" and dist) or (mode=="front" and -dist) or 0
    )
    hrp.CFrame = thrp.CFrame * CFrame.new(offset)
    att0 = Instance.new("Attachment", hrp)
    att1 = Instance.new("Attachment", thrp) ; att1.Position = offset
    alignPos = Instance.new("AlignPosition", hrp)
    alignPos.Attachment0,alignPos.Attachment1 = att0,att1
    alignPos.Responsiveness,alignPos.MaxForce = 50,1e6
    alignOri = Instance.new("AlignOrientation", hrp)
    alignOri.Attachment0,alignOri.Attachment1 = att0,att1
    alignOri.Responsiveness,alignOri.MaxTorque = 50,1e6
    attached = true
    attachBtn.Text = "Attach: ON"
    dodgeBtn.Text = "DODGE"
end

-- Dodge / Touch logic
local function onDodge()
    if attached and returnCF then
        detach()
        local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
        if hrp then hrp.CFrame = returnCF end
        dodgeBtn.Text = "TOUCH"
    elseif dodgeBtn.Text == "TOUCH" and lastTarget then
        attachTo(lastTarget)
    end
end

-- C button toggles mini mode
local function onC()
    smallMode = not smallMode
    if smallMode then
        -- Hide all except prev, next, dodge, C
        for _,v in ipairs(frame:GetChildren()) do
            if v~=prevBtn and v~=nextBtn and v~=dodgeBtn and v~=cBtn then
                hiddenState[v] = v.Visible
                v.Visible = false
            end
        end
        frame.Size = UDim2.new(0, 300, 0, 60)
    else
        for v,vis in pairs(hiddenState) do
            if v.Parent==frame then v.Visible = vis end
        end
        frame.Size = UDim2.new(0, 300, 0, 160)
    end
end

-- Connect events
Players.PlayerAdded:Connect(refreshList)
Players.PlayerRemoving:Connect(refreshList)
lp.CharacterAdded:Connect(function() wait(1) refreshList() end)
searchBox:GetPropertyChangedSignal("Text"):Connect(refreshList)
refreshList()

prevBtn.MouseButton1Click:Connect(function()
    if #playerList>0 then
        idx = idx>1 and idx-1 or #playerList
        selBtn.Text = "Selected: "..playerList[idx].p.DisplayName
        if attached then attachTo(playerList[idx].p) end
    end
end)
nextBtn.MouseButton1Click:Connect(function()
    if #playerList>0 then
        idx = idx<#playerList and idx+1 or 1
        selBtn.Text = "Selected: "..playerList[idx].p.DisplayName
        if attached then attachTo(playerList[idx].p) end
    end
end)
selBtn.MouseButton1Click:Connect(function() if playerList[idx] then attachTo(playerList[idx].p) end end)
attachBtn.MouseButton1Click:Connect(function()
    if attached then detach() elseif playerList[idx] then attachTo(playerList[idx].p) end
end)
dirBtn.MouseButton1Click:Connect(function()
    modeIndex = modeIndex<#modes and modeIndex+1 or 1
    dirBtn.Text = "Direction: "..(modes[modeIndex]:sub(1,1):upper()..modes[modeIndex]:sub(2))
    if attached then attachTo(lastTarget) end
end)
distDec.MouseButton1Click:Connect(function() if dist>1 then dist-=1 end distBox.Text = tostring(dist) if attached then attachTo(lastTarget) end end)
distInc.MouseButton1Click:Connect(function() dist+=1 distBox.Text = tostring(dist) if attached then attachTo(lastTarget) end end)
copyBtn.MouseButton1Click:Connect(function() pcall(function() setclipboard(playerList[idx].p.DisplayName) end) end)
dodgeBtn.MouseButton1Click:Connect(onDodge)
cBtn.MouseButton1Click:Connect(onC)

closeBtn.MouseButton1Click:Connect(function() detach() screen:Destroy() end)
minimizeBtn.MouseButton1Click:Connect(function() frame.Visible=false miniBtn.Position=frame.Position miniBtn.Visible=true end)
miniBtn.MouseButton1Click:Connect(function() frame.Visible=true miniBtn.Visible=false end)

-- Make frames draggable
local function makeDraggable(gui)
    local dragging, dragInput, startPos, origPos
    gui.InputBegan:Connect(function(i)
        if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            startPos = i.Position
            origPos = gui.Position
            i.Changed:Connect(function() if i.UserInputState == Enum.UserInputState.End then dragging = false end end)
        end
    end)
    gui.InputChanged:Connect(function(i)
        if i.UserInputType == Enum.UserInputType.MouseMovement or i.UserInputType == Enum.UserInputType.Touch then
            dragInput = i
        end
    end)
    UIS.InputChanged:Connect(function(i)
        if dragging and i == dragInput then
            local delta = i.Position - startPos
            gui.Position = UDim2.new(origPos.X.Scale, origPos.X.Offset + delta.X,
                                     origPos.Y.Scale, origPos.Y.Offset + delta.Y)
        end
    end)
end

makeDraggable(frame)
makeDraggable(miniBtn)
        print("Button 1 clicked!")
             Fluent:Notify({
            Title = "Notification",
            Content = "Attach Tool Active",
            SubContent = "You can now attach tools to players",
            Duration = 5 -- lasts 5 seconds
        })
    end
})

Tabs.Main:AddButton({
    Title = "Anchor tool",
    Description = "menu for attaching you to your current position",
    Callback = function() -- LocalScript: Freeze Mod Menu (place in StarterPlayer > StarterPlayerScripts)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInput = game:GetService("UserInputService")
local player = Players.LocalPlayer

local function getRootPart(char)
    return char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso")
end

-- State
local freezeOn = false
local attached = false
local markerVisible = false
local flipped = false
local marker, weld

-- Create marker
local function createMarker(cframe)
    local p = Instance.new("Part")
    p.Size = Vector3.new(2,0.2,2)
    p.Anchored = true
    p.CanCollide = false
    p.Transparency = 1
    p.CFrame = cframe
    p.Name = "FreezeMarker"
    p.Parent = workspace
    return p
end

local function attach()
    local char = player.Character or player.CharacterAdded:Wait()
    local root = getRootPart(char)
    if not root or not marker then return end
    root.CFrame = marker.CFrame
    weld = Instance.new("WeldConstraint")
    weld.Part0 = marker
    weld.Part1 = root
    weld.Parent = marker
    attached = true
end

local function detach()
    if weld then weld:Destroy() end
    weld = nil
    attached = false
end

local function toggleFreeze()
    if not freezeOn then
        local char = player.Character or player.CharacterAdded:Wait()
        local root = getRootPart(char)
        if root then
            marker = createMarker(root.CFrame)
            freezeOn = true
            attach()
        end
    else
        detach()
        if marker then marker:Destroy() end
        marker = nil
        freezeOn = false
    end
end

local function toggleAttach()
    if not freezeOn then return end
    if attached then
        detach()
    else
        attach()
    end
end

local function toggleFlip()
    flipped = not flipped
    local char = player.Character
    local root = char and getRootPart(char)
    if root then
        root.CFrame = CFrame.new(root.Position) * CFrame.Angles(math.pi,0,0)
    end
    if marker then
        marker.CFrame = marker.CFrame * CFrame.Angles(math.pi,0,0)
    end
end

local function toggleVisibility()
    markerVisible = not markerVisible
    if marker then
        marker.Transparency = markerVisible and 0.3 or 1
        marker.Color = Color3.fromRGB(170,0,255)
    end
end

-- GUI
local gui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
gui.Name = "FreezeMenu"
gui.ResetOnSpawn = false

local frame = Instance.new("Frame")
frame.Size = UDim2.fromOffset(180, 250)
frame.Position = UDim2.new(0.05,0,0.2,0)
frame.BackgroundColor3 = Color3.fromRGB(30,30,30)
frame.BorderSizePixel = 0
frame.Active = true
frame.Draggable = true
frame.Parent = gui

-- Header
local header = Instance.new("Frame", frame)
header.Size = UDim2.new(1,0,0,28)
header.BackgroundColor3 = Color3.fromRGB(20,20,20)
header.BorderSizePixel = 0

local title = Instance.new("TextLabel", header)
title.Size = UDim2.new(1,-60,1,0)
title.Position = UDim2.fromOffset(8,0)
title.BackgroundTransparency = 1
title.Text = "Freeze Menu"
title.TextColor3 = Color3.fromRGB(255,255,255)
title.Font = Enum.Font.SourceSansBold
title.TextXAlignment = Enum.TextXAlignment.Left

local btnClose = Instance.new("TextButton", header)
btnClose.Size = UDim2.fromOffset(24,24)
btnClose.Position = UDim2.new(1,-28,0.5,-12)
btnClose.BackgroundColor3 = Color3.fromRGB(200,50,50)
btnClose.Text = "X"

local btnMin = Instance.new("TextButton", header)
btnMin.Size = UDim2.fromOffset(24,24)
btnMin.Position = UDim2.new(1,-56,0.5,-12)
btnMin.BackgroundColor3 = Color3.fromRGB(255,165,0)
btnMin.Text = "–"

-- Buttons container
local container = Instance.new("Frame", frame)
container.Size = UDim2.new(1,-20,1,-40)
container.Position = UDim2.fromOffset(10,34)
container.BackgroundTransparency = 1

local list = Instance.new("UIListLayout", container)
list.Padding = UDim.new(0,8)

local function makeButton(text, callback, colorOff, colorOn)
    local b = Instance.new("TextButton", container)
    b.Size = UDim2.new(1,0,0,32)
    b.BackgroundColor3 = colorOff
    b.TextColor3 = Color3.fromRGB(255,255,255)
    b.Font = Enum.Font.SourceSansBold
    b.TextSize = 14
    b.Text = text .. ": OFF"

    local state = false
    b.MouseButton1Click:Connect(function()
        state = not state
        callback(state)
        b.Text = text .. ": " .. (state and "ON" or "OFF")
        b.BackgroundColor3 = state and colorOn or colorOff
    end)

    return b
end

-- Buttons
local freezeBtn = makeButton("Freeze", function(on) toggleFreeze() end,
    Color3.fromRGB(180,40,40), Color3.fromRGB(40,180,40))

local attachBtn = makeButton("Attach", function(on) toggleAttach() end,
    Color3.fromRGB(100,100,100), Color3.fromRGB(200,0,200))

local flipBtn = makeButton("Flip", function(on) toggleFlip() end,
    Color3.fromRGB(60,60,160), Color3.fromRGB(200,120,0))

local visBtn = makeButton("Marker Visible", function(on) toggleVisibility() end,
    Color3.fromRGB(100,100,100), Color3.fromRGB(170,0,255))

-- Minimized circle
local mini = Instance.new("TextButton", gui)
mini.Size = UDim2.fromOffset(44,44)
mini.Position = UDim2.new(0.05,0,0.2,0)
mini.BackgroundColor3 = Color3.fromRGB(255,140,0)
mini.Text = "☰"
mini.Visible = false
mini.Active = true
mini.Draggable = true

btnMin.MouseButton1Click:Connect(function()
    frame.Visible = false
    mini.Visible = true
end)
mini.MouseButton1Click:Connect(function()
    frame.Visible = true
    mini.Visible = false
end)

btnClose.MouseButton1Click:Connect(function()
    gui:Destroy()
    if marker then marker:Destroy() end
end)

-- Keep character locked while attached
RunService.Heartbeat:Connect(function()
    if attached and marker and player.Character then
        local root = getRootPart(player.Character)
        if root then
            root.CFrame = marker.CFrame
            root.AssemblyLinearVelocity = Vector3.zero
            root.AssemblyAngularVelocity = Vector3.zero
        end
    end
end)

-- Reattach after respawn
player.CharacterAdded:Connect(function(char)
    task.wait(0.2)
    if freezeOn and marker then
        attach()
    end
end) 
        print("Anchor Tool clicked!")
            Fluent:Notify({
            Title = "Notification",
            Content = "Anchor Tool Active",
            SubContent = "You can now anchor any point",
            Duration = 3 -- lasts 5 seconds
        })
    end
})

Tabs.Main:AddButton({
    Title = "Bring tool",
    Description = "bring players to you",
    Callback = function()
        print("Freeze tool clicked!")
    end
})

Tabs.Main:AddButton({
    Title = "Button 2",
    Description = "Extra button added",
    Callback = function()
        print("Button 2 clicked!")
    end
})

-- QUICK UTIL TAB

-- Quick Util Toggle
local QuickToggle = Tabs.QuickUtil:AddToggle("QuickToggle", {
    Title = "Invisible Safe Zone",
    Description = "100% see through of original zone",
    Default = false,
    Callback = function(state)
        if state then  -- Create GUI only when toggle is ON
            if not player:FindFirstChild("PlayerGui"):FindFirstChild("SafeZoneGUI") then
                local playerGui = player:WaitForChild("PlayerGui")

                local screenGui = Instance.new("ScreenGui")
                screenGui.Name = "SafeZoneGUI"
                screenGui.ResetOnSpawn = false
                screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
                screenGui.Parent = playerGui

                -- Draggable Button
                local btn = Instance.new("TextButton")
                btn.Name = "DragButton"
                btn.Size = UDim2.new(0,50,0,50)
                btn.Position = UDim2.new(0.4,0,0.4,0)
                btn.BackgroundColor3 = Color3.fromRGB(0,200,0)
                btn.BackgroundTransparency = 0.5
                btn.BorderSizePixel = 0
                btn.Text = ""
                btn.Active = true
                btn.Draggable = true
                btn.ZIndex = 10
                btn.Parent = screenGui

                local label = Instance.new("TextLabel", btn)
                label.Size = UDim2.new(1,0,1,0)
                label.Position = UDim2.new(0,0,0,0)
                label.BackgroundTransparency = 1
                label.Text = "S"
                label.Font = Enum.Font.SourceSansBold
                label.TextSize = 24
                label.TextColor3 = Color3.new(1,1,1)
                label.Active = false
                label.Selectable = false
                label.ZIndex = 11

                -- Safe Zone Logic
                local active, savedCF = false, nil
                local platform, walls, props = nil, {}, {}

                local function clearZone()
                    if platform then
                        platform:Destroy()
                        platform = nil
                    end
                    for _, p in ipairs(walls) do p:Destroy() end
                    for _, p in ipairs(props) do p:Destroy() end
                    walls, props = {}, {}
                end

                local function buildCourtyard(y, size, wallH)
                    local half = size/2
                    platform = Instance.new("Part")
                    platform.Name = "SZFloor"
                    platform.Size = Vector3.new(size,1,size)
                    platform.CFrame = CFrame.new(0,y,0)
                    platform.Anchored = true
                    platform.CanCollide = true
                    platform.Transparency = 1
                    platform.Parent = workspace

                    for _, d in ipairs({
                        {size,wallH,2,0,y+wallH/2,half},
                        {size,wallH,2,0,y+wallH/2,-half},
                        {2,wallH,size,half,y+wallH/2,0},
                        {2,wallH,size,-half,y+wallH/2,0},
                    }) do
                        local w = Instance.new("Part")
                        w.Size = Vector3.new(d[1],d[2],d[3])
                        w.CFrame = CFrame.new(d[4],d[5],d[6])
                        w.Anchored = true
                        w.CanCollide = true
                        w.Transparency = 1
                        w.Parent = workspace
                        table.insert(walls, w)
                    end

                    for _, pos in ipairs({
                        Vector3.new(half-5,y+1,half-15),
                        Vector3.new(-half+5,y+1,half-15),
                        Vector3.new(half-5,y+1,-half+15),
                        Vector3.new(-half+5,y+1,-half+15),
                    }) do
                        local bench = Instance.new("Part")
                        bench.Size = Vector3.new(8,1,2)
                        bench.CFrame = CFrame.new(pos)
                        bench.Anchored = true
                        bench.CanCollide = true
                        bench.Transparency = 1
                        bench.Parent = workspace
                        table.insert(props, bench)
                    end

                    for i = 1,10 do
                        local angle = (i-1)/10*math.pi*2
                        local brick = Instance.new("Part")
                        brick.Size = Vector3.new(3,2,1)
                        brick.CFrame = CFrame.new(3*math.cos(angle),y+1,3*math.sin(angle))*CFrame.Angles(0,-angle,0)
                        brick.Anchored = true
                        brick.CanCollide = true
                        brick.Transparency = 1
                        brick.Parent = workspace
                        table.insert(props, brick)
                    end

                    local firePart = Instance.new("Part")
                    firePart.Size = Vector3.new(1,1,1)
                    firePart.CFrame = CFrame.new(0,y+1.5,0)
                    firePart.Anchored = true
                    firePart.CanCollide = false
                    firePart.Transparency = 1
                    firePart.Parent = workspace
                    table.insert(props, firePart)
                    local emitter = Instance.new("ParticleEmitter", firePart)
                    emitter.Texture = "rbxasset://textures/particles/flame.png"
                    emitter.Lifetime = NumberRange.new(1,1.5)
                    emitter.Rate = 80
                    emitter.Speed = NumberRange.new(1,3)
                    emitter.Size = NumberSequence.new{
                        NumberSequenceKeypoint.new(0,1),
                        NumberSequenceKeypoint.new(1,0)
                    }
                    emitter.LightEmission = 0.8

                    for _, xOffset in ipairs({-half+10,half-10}) do
                        local trunk = Instance.new("Part")
                        trunk.Size = Vector3.new(2,12,2)
                        trunk.CFrame = CFrame.new(xOffset,y+6,-half+8)
                        trunk.Anchored = true
                        trunk.CanCollide = true
                        trunk.Transparency = 1
                        trunk.Parent = workspace
                        table.insert(props, trunk)

                        for j = 0,2 do
                            local leaf = Instance.new("Part")
                            leaf.Shape = Enum.PartType.Ball
                            leaf.Size = Vector3.new(8-j*2,4,8-j*2)
                            leaf.CFrame = CFrame.new(xOffset,y+12+j*3,-half+8)
                            leaf.Anchored = true
                            leaf.CanCollide = false
                            leaf.Transparency = 1
                            leaf.Parent = workspace
                            table.insert(props, leaf)
                        end
                    end

                    for _, corner in ipairs({
                        Vector3.new(half-5,y+0.5,half-5),
                        Vector3.new(half-5,y+0.5,-half+5),
                        Vector3.new(-half+5,y+0.5,half-5),
                        Vector3.new(-half+5,y+0.5,-half+5),
                    }) do
                        for i = 1,8 do
                            local flower = Instance.new("Part")
                            flower.Size = Vector3.new(1,1,1)
                            flower.CFrame = CFrame.new(
                                corner.X + math.random(-2,2),
                                corner.Y,
                                corner.Z + math.random(-2,2)
                            )
                            flower.Anchored = true
                            flower.CanCollide = false
                            flower.Transparency = 1
                            flower.Shape = Enum.PartType.Cylinder
                            flower.Orientation = Vector3.new(90,0,0)
                            flower.Parent = workspace
                            table.insert(props, flower)
                        end
                    end

                    for _, d in ipairs({
                        {half-8,half-8},
                        {half-8,-half+8},
                        {-half+8,half-8},
                        {-half+8,-half+8},
                    }) do
                        local post = Instance.new("Part")
                        post.Size = Vector3.new(1,8,1)
                        post.CFrame = CFrame.new(d[1],y+4,d[2])
                        post.Anchored = true
                        post.CanCollide = true
                        post.Transparency = 1
                        post.Parent = workspace
                        table.insert(props, post)

                        local lantern = Instance.new("Part")
                        lantern.Size = Vector3.new(1.5,1.5,1.5)
                        lantern.CFrame = CFrame.new(d[1],y+7,d[2])
                        lantern.Anchored = true
                        lantern.CanCollide = false
                        lantern.Transparency = 1
                        lantern.Parent = workspace
                        table.insert(props, lantern)

                        local light = Instance.new("PointLight", lantern)
                        light.Range = 25
                        light.Brightness = 2
                        light.Color = Color3.fromRGB(255,200,100)
                    end
                end

                -- Button Click
                btn.MouseButton1Click:Connect(function()
                    local char = player.Character
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    if not hrp then return end

                    if not active then
                        savedCF = hrp.CFrame
                        buildCourtyard(1000,80,25)
                        hrp.CFrame = CFrame.new(0,1005,0)
                        active = true
                    else
                        if savedCF then hrp.CFrame = savedCF end
                        clearZone()
                        active = false
                    end
                end)

                -- Draggable
                local dragging, dragInput, dragStart, startPos
                btn.InputBegan:Connect(function(inp)
                    if inp.UserInputType == Enum.UserInputType.Touch or inp.UserInputType == Enum.UserInputType.MouseButton1 then
                        dragging, dragStart, startPos = true, inp.Position, btn.Position
                        inp.Changed:Connect(function()
                            if inp.UserInputState == Enum.UserInputState.End then
                                dragging = false
                            end
                        end)
                    end
                end)

                btn.InputChanged:Connect(function(inp)
                    if inp.UserInputType == Enum.UserInputType.Touch or inp.UserInputType == Enum.UserInputType.MouseMovement then
                        dragInput = inp
                    end
                end)

                UIS.InputChanged:Connect(function(inp)
                    if inp == dragInput and dragging then
                        local delta = inp.Position - dragStart
                        btn.Position = UDim2.new(
                            startPos.X.Scale, startPos.X.Offset + delta.X,
                            startPos.Y.Scale, startPos.Y.Offset + delta.Y
                        )
                    end
                end)
            end
        else
            -- Destroy GUI and all safe zone parts when toggle is OFF
            local gui = player:FindFirstChild("PlayerGui"):FindFirstChild("SafeZoneGUI")
            if gui then
                gui:Destroy()
            end
        end
    end
})


-- Quick Util Button
Tabs.QuickUtil:AddButton({
    Title = "Ink game tele",
    Description = "menu to teleport in ink game and win",
    Callback = function() local Players = game:GetService("Players")
local player = Players.LocalPlayer

local function getHRP()
    local char = player.Character or player.CharacterAdded:Wait()
    return char:WaitForChild("HumanoidRootPart")
end

local lastPos
local MENU_WIDTH, MENU_HEIGHT, BUTTON_HEIGHT = 200, 160, 30

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "TeleportMenuGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")

local menu = Instance.new("Frame")
menu.Name = "TeleportMenu"
menu.Size = UDim2.new(0, MENU_WIDTH, 0, MENU_HEIGHT)
menu.Position = UDim2.new(0.5, -MENU_WIDTH/2, 0.5, -MENU_HEIGHT/2)
menu.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
menu.Active = true
menu.Draggable = true
menu.Parent = screenGui
Instance.new("UICorner", menu).CornerRadius = UDim.new(0, 8)

local titleBar = Instance.new("Frame")
titleBar.Size = UDim2.new(1, 0, 0, 24)
titleBar.BackgroundTransparency = 1
titleBar.Parent = menu

local title = Instance.new("TextLabel")
title.Size = UDim2.new(0.6, 0, 1, 0)
title.Position = UDim2.new(0, 8, 0, 0)
title.BackgroundTransparency = 1
title.Text = "Teleport Menu"
title.TextColor3 = Color3.new(1,1,1)
title.Font = Enum.Font.SourceSansBold
title.TextSize = 18
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = titleBar

local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 24, 0, 24)
closeBtn.Position = UDim2.new(1, -28, 0, 0)
closeBtn.BackgroundTransparency = 1
closeBtn.Text = "X"
closeBtn.TextColor3 = Color3.new(1,1,1)
closeBtn.Font = Enum.Font.SourceSansBold
closeBtn.TextSize = 18
closeBtn.Parent = titleBar

local minBtn = Instance.new("TextButton")
minBtn.Size = UDim2.new(0, 24, 0, 24)
minBtn.Position = UDim2.new(1, -56, 0, 0)
minBtn.BackgroundTransparency = 1
minBtn.Text = "-"
minBtn.TextColor3 = Color3.new(1,1,1)
minBtn.Font = Enum.Font.SourceSansBold
minBtn.TextSize = 18
minBtn.Parent = titleBar

local function makeTeleportRow(label, yOffset, target)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0, MENU_WIDTH - 50, 0, BUTTON_HEIGHT)
    btn.Position = UDim2.new(0, 8, 0, yOffset)
    btn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    btn.TextColor3 = Color3.new(1,1,1)
    btn.Font = Enum.Font.SourceSans
    btn.TextSize = 16
    btn.Text = label
    btn.Parent = menu

    local ret = Instance.new("TextButton")
    ret.Size = UDim2.new(0, 30, 0, BUTTON_HEIGHT)
    ret.Position = UDim2.new(0, MENU_WIDTH - 40, 0, yOffset)
    ret.BackgroundColor3 = Color3.fromRGB(200,50,50)
    ret.TextColor3 = Color3.new(1,1,1)
    ret.Font = Enum.Font.SourceSansBold
    ret.TextSize = 18
    ret.Text = "C"
    ret.Parent = menu

    btn.MouseButton1Click:Connect(function()
        lastPos = getHRP().Position
        getHRP().CFrame = CFrame.new(target)
    end)
    ret.MouseButton1Click:Connect(function()
        if lastPos then
            getHRP().CFrame = CFrame.new(lastPos)
        end
    end)
end

makeTeleportRow("Redlight",    40,  Vector3.new(-45.45, 1024.76, 137.14))
makeTeleportRow("Jump Rope",   80,  Vector3.new(728.95, 197.14, 920.46))
makeTeleportRow("Glass Bridge",120, Vector3.new(-197.33, 520.73, -1531.36))
makeTeleportRow("Guard lock",  160, Vector3.new(197.47, 56.51, 56.09))

-- Minimized pink button as TextButton for click events
local circle = Instance.new("TextButton")
circle.Name = "MinimizedButton"
circle.Size = UDim2.new(0, 32, 0, 32)
circle.BackgroundColor3 = Color3.fromRGB(255,105,180)
circle.Text = ""
circle.Visible = false
circle.Active = true
circle.Draggable = true
circle.Parent = screenGui
Instance.new("UICorner", circle).CornerRadius = UDim.new(1,0)

minBtn.MouseButton1Click:Connect(function()
    menu.Visible = false
    local mPos = menu.Position
    circle.Position = UDim2.new(
        mPos.X.Scale, mPos.X.Offset + MENU_WIDTH/2 - 16,
        mPos.Y.Scale, mPos.Y.Offset + MENU_HEIGHT/2 - 16
    )
    circle.Visible = true
end)

closeBtn.MouseButton1Click:Connect(function()
    screenGui:Destroy()
end)

circle.MouseButton1Click:Connect(function()
    local cPos = circle.Position
    menu.Position = UDim2.new(
        cPos.X.Scale, cPos.X.Offset - MENU_WIDTH/2 + 16,
        cPos.Y.Scale, cPos.Y.Offset - MENU_HEIGHT/2 + 16
    )
    menu.Visible = true
    circle.Visible = false
end) 
        print("Quick Button clicked!")
    end
})

-- MINIMIZER (Custom Icon, no outline, bigger image, positioned higher)
local Minimizer = Fluent:CreateMinimizer({
    Icon = "rbxassetid://120242305941983",
    Size = UDim2.fromOffset(60, 60), -- larger area
    Position = UDim2.new(0, 400, 0, 0), -- moved closer to the top
    Acrylic = false, -- remove acrylic background
    Corner = 20,
    Transparency = 1,
    Draggable = true,
    Visible = true
})

-- Adjust icon to fully cover and extend beyond box
if Minimizer.Icon then
    Minimizer.Icon.Image = "rbxassetid://120242305941983"
    Minimizer.Icon.Size = UDim2.new(1.2, 0, 1.2, 0) -- 120% of minimizer area
    Minimizer.Icon.Position = UDim2.new(-0.1, 0, -0.1, 0) -- re-center oversized icon
    Minimizer.Icon.BackgroundTransparency = 0
    Minimizer.Icon.BorderSizePixel = 0 -- remove outline
    Minimizer.Icon.ScaleType = Enum.ScaleType.Fit -- keep proportions
end

-- Also kill any extra borders on minimizer container
if Minimizer then
    Minimizer.BorderSizePixel = 0
    Minimizer.BackgroundTransparency = 0
end
